{"name":"FliterSC","body":"F-liter Supercompiler\r\n=====================\r\n\r\n*Debug variant.*    [![Build Status](https://secure.travis-ci.org/jasonreich/FliterSC.png?branch=debug)](http://travis-ci.org/jasonreich/FliterSC)\r\n\r\nA reimplementation of the Bollingbroke & Peyton-Jones (2010) compiler\r\nfor the F-liter language in an attempt to understand it\r\nbetter. Currently packaged as a library and as is. \r\n\r\nTry;\r\n<pre>\r\n$ ghci Supercompiler\r\nλ> ex_mapmap\r\nmain  = let x = Nil\r\n        in sc x\r\nsc x = let y = inc\r\n       in\r\n          let z = map y x\r\n          in map y z\r\nmap x y = case y of\r\n            Nil  -> Nil\r\n            Cons z p -> let\r\n                            q = x z\r\n                            r = map x p\r\n                        in Cons q r\r\ninc x = let y = 1\r\n        in x + y\r\nλ> sc_wrapper ex_mapmap (\"sc\", lam \"xs\" $ fun \"sc\" @: \"xs\")\r\n...\r\n</pre>\r\n\r\nIt will supercompile the function `sc` of program `ex_mapmap` with an\r\nunknown input. \r\n\r\n\r\nExtra debug features\r\n--------------------\r\n\r\nTo aid debugging, the `Debug.RocketFuel` library prematurely\r\nterminates supercompilation when a predetermined \"fuel\" supply\r\nis depleted. This a very unsafe implementation of the concept\r\nintroduced in Whalley's (1994) *Automatic isolation of compiler\r\nerrors.*\r\n\r\nBy default, the fuel tank is infinite (i.e. `Nothing`).\r\n\r\n*  `fuelTank` is a global variable.\r\n*  `disableTank` creates infinite fuel.\r\n*  `fillTank n` creates a finite pool of `n` units of fuel.\r\n*  `consumeFuel empty full` will consume 1 unit of fuel. If the tank\r\n   is depleted, it returns `empty`, otherwise `full`.\r\n*  `readTank` returns the fuel tank value.","tagline":"Supercompiler for F-liter, based on Bollingbroke & Peyton-Jones (2010)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}